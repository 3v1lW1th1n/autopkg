#!/usr/bin/env python
#
# Copyright 2013 Greg Neagle
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import glob
import sys
import os
import optparse
import plistlib
import pprint
import subprocess
import time

from autopkglib import BUNDLE_ID
from autopkglib import AutoPackagerError, AutoPackager

def is_munki_recipe(recipe_plist):
    if "Process" in recipe_plist:
        processors = [step.get("Processor") for step in recipe_plist["Process"]]
        if "MunkiImporter" in processors:
            return True
    return False
    
    
def has_check_phase(recipe_plist):
    if "Process" in recipe_plist:
        processors = [step.get("Processor") for step in recipe_plist["Process"]]
        if "EndOfCheckPhase" in processors:
            return True
    return False


def valid_recipe(filename):
    '''Returns True if filename contains a valid
    recipe, otherwise returns False'''
    try:
        # make sure we can read it
        recipe_plist = plistlib.readPlist(filename)
    except:
        return False
    if "Input" in recipe_plist and "Process" in recipe_plist:
        # needs to have at least Input and Process arrays
        return True
    return False
    
    
def valid_override(filename):
    '''Returns True if filename contains a valid
    override, otherwise returns False'''
    try:
        # make sure we can read it
        recipe_plist = plistlib.readPlist(filename)
    except:
        return False
    if "Input" in recipe_plist and "Recipe" in recipe_plist:
        # needs to have at least Input and Recipe keys
        return True
    return False


def find_recipe(name, search_dirs, kind="default"):
    for directory in search_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        patterns  = [
            os.path.join(normalized_dir, "%s.plist" % name),
            os.path.join(normalized_dir, "%s/%s.plist" % (name, name)),
            os.path.join(normalized_dir, "%s/_%s.plist" % (name, kind)),
            os.path.join(normalized_dir, "%s/_default.plist" % name),
            os.path.join(normalized_dir, "*/%s.plist" % name)
        ]
        for pattern in patterns:
            matches = glob.glob(pattern)
            for match in matches:
                if valid_recipe(match):
                    return match
    return None


def load_recipe(name, override_dirs, recipe_dirs, kind="default"):
    '''Loads a recipe. If the name contains a path seperator or a file
    extension , we assume the name is a pathname and attempt to load the
    override or recipe from the pathname. 
    Otherwise, we treat name as a simple name and search first the override
    directories, then the recipe directories for a matching recipe.
    If we find one, we load it and return the plist object (which should be 
    functionally equivelent to a dictionary).'''
    
    override = None
    if "/" in name or len(os.path.splitext(name)) > 1:
        # name is path to a specific recipe or override file
        # ignore override and recipe directories and kind
        if valid_override(name):
            override = plistlib.readPlist(pathname)
            name = override['Recipe'].get("name")
            kind = override['Recipe'].get("kind", "default")
            override["OVERRIDE_PATH"] = os.path.abspath(pathname)
            # fall through to get the actual recipe
        elif valid_recipe(name):
            recipe = plistlib.readPlist(name)
            recipe["RECIPE_PATH"] = os.path.abspath(name)
            return recipe
            
    if not override:
        # first look in override_dirs for name.plist
        filename = name + ".plist"
        for directory in override_dirs:
            normalized_dir = os.path.abspath(os.path.expanduser(directory))
            if filename in os.listdir(normalized_dir):
                pathname = os.path.join(normalized_dir, filename)
                if valid_override(pathname):
                    override = plistlib.readPlist(pathname)
                    name = override['Recipe'].get("name")
                    kind = override['Recipe'].get("kind", "default")
                    override["OVERRIDE_PATH"] = os.path.abspath(pathname)

    # now get the actual recipe
    if name:
        recipe_path = find_recipe(name, recipe_dirs, kind)
        if recipe_path:
            recipe = plistlib.readPlist(recipe_path)
            # apply overrides
            if override:
                recipe["OVERRIDE_PATH"] = override["OVERRIDE_PATH"]
                for key in override["Input"].keys():
                    recipe["Input"][key] = override["Input"][key]
            # store the recipe path for 
            recipe["RECIPE_PATH"] = os.path.abspath(recipe_path)
            return recipe
    return None


def get_recipe_info(recipe_name, override_dirs, recipe_dirs, kind="default"):
    recipe = load_recipe(recipe_name, override_dirs, recipe_dirs, kind=kind)
    if recipe:
        print "Description:         %s" % recipe.get("Description")
        print "Munki import recipe: %s" % is_munki_recipe(recipe)
        print "Has check phase:     %s" % has_check_phase(recipe)
        print "Recipe file path:    %s" % recipe["RECIPE_PATH"]
        if recipe.get("OVERRIDE_PATH"):
            print "Override path:       %s" % recipe["OVERRIDE_PATH"]
        print "Input values: "
        #pprint.pprint(recipe_plist["Input"], indent=4)
        output = pprint.pformat(recipe.get("Input", {}), indent=4)
        print " " + output[1:-1]
        return True
    else:
        return False


def list_recipes(override_dirs, search_dirs):
    recipes = set()
    
    # find all valid overrides first
    for directory in override_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        for filename in os.listdir(normalized_dir):
            if filename.endswith(".plist"):
                pathname = os.path.join(normalized_dir, filename)
                if valid_override(pathname):
                    override = plistlib.readPlist(pathname)
                    name = override['Recipe'].get("name")
                    kind = override['Recipe'].get("kind", "default")
                    # find and validate recipe that will be overridden
                    recipe_path = find_recipe(name, search_dirs, kind)
                    if valid_recipe(recipe_path):
                        # override points to a valid recipe
                        recipes.add(os.path.splitext(filename)[0])
    
    for directory in search_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        # find all top-level recipes
        matches = glob.glob(os.path.join(normalized_dir, "*.plist"))
        for match in matches:
            if valid_recipe(match):
                basename = os.path.basename(match)
                recipes.add(os.path.splitext(basename)[0])

        # look for recipes one level down
        matches = glob.glob(os.path.join(normalized_dir, "*/*.plist"))
        for match in matches:
            if valid_recipe(match):
                recipe_name = os.path.basename(match)
                if recipe_name.startswith("_"):
                    # recipe variation or "kind"
                    # use the dirname
                    dirname = os.path.dirname(match)
                    recipe_name = os.path.basename(dirname)

                # get rid of file extension
                recipe_name = os.path.splitext(recipe_name)[0]
                recipes.add(recipe_name)

    return sorted(list(recipes))


def makecatalogs(repo_path):
    # Generate arguments for makecatalogs.
    args = ["/usr/local/munki/makecatalogs", repo_path]
    
    # Call makecatalogs.
    try:
        proc = subprocess.Popen(
            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err_out) = proc.communicate()
    except OSError as err:
        print >> sys.stderr, (
            "makecatalog execution failed with error code %d: %s" 
            % (err.errno, err.strerror))
    if proc.returncode != 0:
        print >> sys.stderr, (
            "makecatalogs failed: %s" % err_out)
    print "Munki catalogs rebuilt!"


def print_new_imports(new_imports):
    print "    %-24s %-16s %-32s %s" % (
        "Name", "Version", "Catalogs", "Pkginfo Path")
    print "    %-24s %-16s %-32s %s" % (
        "----", "-------", "--------", "------------")
    for item in new_imports:
        print "    %-24s %-16s %-32s %s" % (
            item["name"], item["version"], item["catalogs"],
            item["pkginfo_path"].partition("pkgsinfo/")[2])


def main(argv):
    # Parse arguments.
    p = optparse.OptionParser()
    p.set_usage("Usage: %prog [options] [recipe ...]")
    p.add_option("-c", "--check", action="store_true",
                 help="Only check for new/changed downloads.")
    p.add_option("-k", "--key", action="append", dest="variables", default=[],
                 metavar="KEY=VALUE",
                 help=("Provide key/value pairs for recipe input. "
                       "Caution: values specified here will be applied "
                       "to all recipes."))
    p.add_option("-l", "--list", metavar="TEXT_FILE",
                 help="Path to a text file with a list of recipes to run.")
    p.add_option("--list-recipes", dest="list_recipes", action="store_true",
                 help="List all the recipes this tool can find automatically.")
    p.add_option("-p", "--pkg", metavar="PKG_OR_DMG",
                 help=("Path to a pkg or dmg to provide to a recipe. "
                       "Downloading will be skipped."))
    p.add_option("--recipe-info", "--info", metavar="RECIPE_NAME", 
                 dest="recipe_info", action="store_true",
                 help="Print information about a recipe.")
    p.add_option("-v", "--verbose", action="count", default=0,
                 help="Verbose output.")
    p.add_option("-r", "--recipe-dir", metavar="RECIPE_ROOT_DIR",
                 help=("Path to a directory that will be searched "
                       "recursively for all autopkg recipe plists."))
    options, argv = p.parse_args(argv)
    
    munki_repo_path = None
    new_downloads = []
    new_imports = []
    failures = []
    
    recipe_dir_list = [
        ".",
        "~/Library/AutoPkg/Recipes",
        "/Library/AutoPkg/Recipes"
        ]
    
    override_dir_list = [
        "~/Library/AutoPkg/RecipeOverrides"
        ]
    
    if options.list_recipes:
        recipe_list = list_recipes(override_dir_list, recipe_dir_list)
        print "\n".join(recipe_list)
        return 0
    
    # Add variables from commandline.
    cli_values = {}
    for arg in options.variables:
        (key, sep, value) = arg.partition("=")
        if sep != "=":
            print >> sys.stderr, "Invalid variable [key=value]: %s" % arg
            print >> sys.stderr, p.get_usage()
            return 1
        cli_values[key] = value
        
    if options.pkg:
        cli_values["PKG"] = options.pkg
        
    recipe_paths = []
    recipe_paths.extend(argv[1:])
    if options.list:
        with open(options.list, "r") as fd:
            data = fd.read()
        recipes = [line for line in data.splitlines() 
                   if line and not line.startswith("#")]
        recipe_paths.extend(recipes)

    if options.recipe_dir:
        for root, dirs, files in os.walk(options.recipe_dir):
            for f in [r for r in files if r.endswith(".plist")]:
                recipe_path = os.path.join(root, f)
                try:
                    recipe_plist = plistlib.readPlist(recipe_path)
                except:
                    print >> sys.stderr, (
                        "Error reading plist file %s" % recipe_path)
                    return 1
                if all(k in recipe_plist.keys() for k in ["Input", "Process"]):
                    recipe_paths.append(recipe_path)
                else:
                    print >> sys.stderr, ("Skipping plist %s as it's not a "
                        "(properly-formatted) autopkg recipe plist." 
                        % recipe_path)
        
    if not recipe_paths:
        print >> sys.stderr, p.get_usage()
        return 1
        
    if len(recipe_paths) > 1 and options.pkg:
        print >> sys.stderr, (
            "-p/--pkg option can't be used with multiple recipes!")
        return 1
        
    if options.recipe_info:
        if get_recipe_info(
            recipe_paths[0], override_dir_list, recipe_dir_list, kind="munki"):
            return 0
        else:
            print >> sys.stderr, (
                "Can't find recipe %s" % recipe_paths[0])
            return -1
    
    run_results = []
    for recipe_path in recipe_paths:
        recipe = load_recipe(
            recipe_path, override_dir_list, recipe_dir_list, kind="munki")
        if not recipe:
            print >> sys.stderr, "No valid recipe found for %s" % recipe_path
            continue
        
        if options.check:
            # remove steps from the end of the recipe Process until we find a 
            # EndOfCheckPhase step
            while len(recipe["Process"]) >= 1 and \
                    recipe["Process"][-1]["Processor"] != "EndOfCheckPhase":
                del recipe["Process"][-1]
            if len(recipe["Process"]) == 0:
                print >> sys.stderr, (
                    "Recipe at %s is missing EndOfCheckPhase Processor, "
                    "not possible to perform check." % recipe_path)
                continue
    
        print "Processing %s..." % recipe_path
        # Create empty plist object to hold preferences.
        prefs = plistlib.readPlistFromString(plistlib.writePlistToString({}))
    
        # Read preferences from system and user's library path.
        for libdir in ("/Library", os.path.expanduser("~/Library")):
            prefpath = os.path.join(libdir, "Preferences", BUNDLE_ID + ".plist")
            if os.path.exists(prefpath):
                try:
                    prefs = plistlib.readPlist(prefpath)
                except BaseException as e:
                    print >> sys.stderr, (
                        "Can't read preferences from %s: %s" 
                        % (prefpath, e))
    
        # Add RECIPE_PATH and RECIPE_DIR variables for use by processors
        prefs["RECIPE_PATH"] = os.path.abspath(recipe["RECIPE_PATH"])
        prefs["RECIPE_DIR"] = os.path.dirname(prefs["RECIPE_PATH"])
    
        # Add our verbosity level
        prefs["verbose"] = options.verbose
    
        autopackager = AutoPackager(options, prefs)
    
        exit_status = 0
        exit_string = ""
    
        try:
            autopackager.process_input_overrides(recipe, cli_values)
            autopackager.verify(recipe)
            autopackager.process(recipe)
        except AutoPackagerError as e:
            print "Failed."
            failure = {}
            failure["recipe"] = recipe_path
            failure["message"] = str(e)
            failures.append(failure)

        run_results.append(autopackager.results)
        # look through results for interesting info
        # and record for later summary and use
        for item in autopackager.results:
            if item.get("Recipe input"):
                # the assumption is that the MUNKI_REPO does not
                # change from recipe to recipe; if it does, running
                # makecatalogs later will affect only the "last"
                # MUNKI_REPO
                munki_repo_path = item["Recipe input"].get("MUNKI_REPO")
            if item.get("Processor") == "URLDownloader":
                if item["Output"].get("download_changed"):
                    new_downloads.append(item["Output"].get("pathname"))
            if item.get("Processor") == "MunkiImporter":
                if item["Output"].get("pkginfo_repo_path"):
                    imported_item = {}
                    imported_item["name"] = item["Output"]["munki_info"]["name"]
                    imported_item["version"] = item[
                                            "Output"]["munki_info"]["version"]
                    imported_item["catalogs"] = item[
                                            "Output"]["munki_info"]["catalogs"]
                    imported_item["pkginfo_path"] = item["Output"].get(
                                                            "pkginfo_repo_path")
                    imported_item["pkg_path"] = item["Output"].get(
                                                                "pkg_repo_path")
                    new_imports.append(imported_item)
                         
    # done running recipes, print a summary
    if failures:
        print
        print "The following recipes failed:"
        for item in failures:
            print "    %s" % item["recipe"]
            print "        %s" % item["message"]
            
    if new_downloads:
        print
        print "The following new items were downloaded:"
        for item in new_downloads:
            print "    %s" % item
    
    if new_imports:
        print
        print "The following new items were imported:"
        print_new_imports(new_imports)
        print
        # rebuild Munki catalogs since we imported new items
        makecatalogs(munki_repo_path)
            
    if not new_downloads and not new_imports:
        print
        print "No changes found."
        
    #pprint.pprint(run_results)
        

if __name__ == "__main__":
    sys.exit(main(sys.argv))
    
